# 记录了哪些内容？

- 了解HTTP协议
- cookie和session
- HTTP缓存机制

# 什么是HTTP协议？

HTTP是超文本传输协议，从www服务器传输到本地浏览器的一种传输协议，我们的网站，包括css，js，图片等等都是基于HTTP协议传输的。

那么他是用来干什么的呢？

对客户端到服务器的请求和从服务器到客户端的响应进行约束和规范的。

它是怎么工作的呢？

HTTP的工作过程分为4步，而一次HTTP操作称为一个事务，如果其中的某一步出现错误的话，那么产生错误的信息就会返回到客户端并显示出来。

1. 首先客户端和服务器进行连接。只要点击某个超级链接，HTTP的工作就开始了。
2. 建立了连接之后客户端会向服务器发送一个请求，请求的格式为：统一的资源标识符（URL），协议版本号（HTTP1.1/HTTP2/HTTPS），后面是MIME信息包括请求修饰符，客户端信息和一些内容。
3. 服务器接收到请求后，会给予客户端响应，其格式是一个状态行，包括信息的协议版本号，一个成功或错误的状态码，后面是MIME信息或阔服务器信息，实体信息和一些内容。
4. 客户端接收到服务器返回的信息后，将它显示在屏幕上，然后客户端和服务器断开连接。

这样一次HTTP请求就完成了。为什么要断开连接呢，因为HTTP请求属于I/O操作，而I/O资源是非常宝贵的，当你使用完了之后需要断开不要占位置。

那么在浏览器中，我们发送一次HTTP请求会经历哪些步骤呢？

1. 用户输入URL，按下回车
2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期
3. 对用户输入的URL进行域名解析
4. 进行TCP连接
5. 浏览器发送HTTP请求
6. 服务端处理请求
7. 服务端对客户端的请求进行响应
8. 客户端渲染HTML页面
9. 断开TCP连接

# HTTP和TCP协议

在具体了解HTTP和TCP的关系之前我们先了解一下网络分层。

## 两种网络分层

目前的分层方法有两种，一种是分为7层，一种是分为4层。



| 7层网络分层 |        4层网络分层         |
| :---------: | :------------------------: |
|   应用层    |           应用层           |
|   表示层    |                            |
|   会话层    |                            |
|   传输层    | 传输层（TCP，UDP所在位置） |
|   网络层    |  网络层（IP协议所在位置）  |
| 数据链路层  |         网络接口层         |
|   物理层    |         网络接口层         |

TCP协议所在的网络分层是传输层，IP协议所在的网络分层是网络层。而HTTP所在的网络分层是应用层。

为什么HTTP协议要基于TCP协议呢？我们不能直接使用TCP协议通信吗？

首先TCP协议所在的网络分层是传输层，这样没有应用层的参与会导致两端无法识别数据内容。因此如果想让数据可以识别的话那么就必须要用到应用层的协议。

其次TCP/IP协议可以通过三次握手建立稳定的通信通道。有较高的可靠性。

HTTP的默认短口号为80，HTTPS的默认端口号是443.

# HTTP的请求和响应

HTTP请求组成：请求行，消息报头，请求正文

HTTP响应组成：响应行，消息报头，响应正文

请求组成都以一个方法符号开头，后面跟着请求的URI和协议的版本

> GET   /    HTTP/1.1

状态行组成都以服务器的HTTP版本，服务器返回的响应状态吗和状态代码的文本描述组成

> HTTP/1.1   200   OK

### 浏览器network中的Request Headers是由哪些部分构成的呢？

第一行是请求行，以一个回车符加换行符结束

> 请求方法｜空格｜URL｜空格｜协议版本｜回车符加换行符

中间的多行属于请求头部，他有一段KEY ： Value 组成，每一段Key：Value也是由回车符加换行符结束

> 头部名字段（key）｜：｜value｜回车符换行符
>
> ...... （这里可能有多个key：value）
>
> 头部名字段（key）｜：｜value｜回车换行符

最后是请求的数据，一般为post方法请求时候带的参数、

### Response Headers 有哪些部分呢？

和Request Headers组成一样，响应组成有：响应行，响应头，响应体，他们没一行都是由回车符加换行符结束的。

响应行:

> 报文协议 ｜ 状态码｜状态描述

响应头：和请求头部一样，也是key：value 组成

响应体：服务端响应的信息。

## HTTP Headers

包括通用报头，请求报头，响应报头，实体报头。

## 常用的请求头字段有哪些呢？

以百度首页为例子：

| Accept                    | 可以接受的类型的资源                                         |
| ------------------------- | ------------------------------------------------------------ |
| Accept-Encoding           | 表示HTTP响应是否进行压缩                                     |
| Cache-Control             | 通用消息头，被用于请求和响应中，通过指令来实现缓存机制       |
| Connection                | 决定当前事务完成后是否会关闭网络连接                         |
| Cookie                    | 服务端通过set-cookie存储到客户端的数据                       |
| Host                      | 将要发送到的服务器主机名和端口号                             |
| Referer                   | 当前页面是从哪个页面过来的                                   |
| Upgrade-Insecure-Requests | 是一个请求首部，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应 |
| User-Agent                | 让服务器识别发起请求的用户端的应用类型，操作系统等信息       |

## Cookie 和 Session

Cookie是保存在客户端的小段文本 ，一般是由服务端来创建并传输给客户端，虽然客户端也有可以创建的API。

session是保存在服务端，通过一个唯一的ID来区别每一个用户。服务器根据sessionID来识别客户端，再通过Key来获取value。

他们是如何搭配使用的呢？

一般在客户端第一次请求的时候，服务端会向客户端通过set-Cookie来设置cookie，客户端在新的请求中再把这些内容携带到HTTP头的cookie里发送给服务器，从而实现会话的保持。

## 关于浏览器缓存

有两种缓存策略，分别是强制环翠和比较缓存。

强制缓存：

> 服务器同志浏览器一个缓存时间，在这段时间内，下次请求直接使用缓存。不在时间内执行比较缓存策略。

比较缓存

> 将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由 服务器校验，返回304状态码时，浏览器直接使用缓存

Etag策略和Last-Modified策略

Etag向服务器请求时带： If-None-Match ，他比Last-Modified更为精确

Last-MOdified向服务器请求时带：If-modified-Since，他使用时间戳，只能精确到秒级，不是特别精准。

## 关于HTTPS

HTTPS的安全性由SSL/TLS协议实现。在HTTP内部嵌入了SSL/TLS协议。

他们的关系：

HTTPS是基于SSL的HTTP协议，HTTPS协议安全是由SSL协议实现的。

TLS协议是SSL的后续版本。目前默认使用TLS1.2版本。

## HTTP2.0

没有改动HTTP原有的应用语义，HTTP的方法，状态码，URI，标头字段等核心概念没有改变。但是它修改了数据格式化以及在客户端与服务器之间传输的方式。

## HTTP2.0 的特点

1. 使用二进制格式传输，更高效更紧凑
2. 对报头进行压缩，降低开销
3. 多路复用，一个网络连接实现并行请求
4. 服务器主动推送，减少请求的延迟
5. 默认使用加密

