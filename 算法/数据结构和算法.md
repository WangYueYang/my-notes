# 认识数据结构

 #### 基本概念

- 数据
- 数据对象
- 数据元素
- 数据项
- 数据结构

————————

- 逻辑结构：理论上的东西
  - 集合
  - 线性结构（线性表）结构必须是连续的，必须是一维的
    - 一维数组
    - 队列
    - 栈
    - 串，流
  - 非线性结构
    - 树
    - 图
    - 多维数组
- 存储结构：应用上的东西，（下面的存储结构都依托于上面的）
  - 顺序存储
  - 链式存储
  - 索引存储
  - 散列存储

### 内存和存储结构

1. 内存-相当于一个一维的线形结构
2. 地址（最小的单位字节都被编上了地址）、指针（保存地址的变量）和引用（对指针的封装）
3. 存储结构（数据在内存里如何摆放的）与内存管理（内存碎片和数据存储位置）

### 集合

集合重的数据成员是无序的，并且成员只出现一次不能重复

### 线性表

线性结构中的数据元素之间是一对一的关系，他们一个接一个的排列

- 用来存放特定的某一个类型的元素
- 物理结构为顺序表和链表

线性表的衍生结构

> 1. 栈 
> 2. 队列
> 3. 串

### 栈

栈是一种呗限制操作的线性表

只能从一端操作（栈顶）就好像水杯一样只能从顶端倒水

栈的特点：后进先出（类似于倒水，摞盘子，竖桶的薯片）

### 队列

也是一种呗限制操作的线性表，队列可以操作两头，

队列的特点：先入先出，（像排队，隧道）

### 树

树是由若干个有限节点组成的一个具有层次关系的集合

- 数学基础是：图论
- 一棵树中每两个点之间都有且只有一条路
- 一个有N个点的树有N-1条边
- 每一层叫做深（depth）,比如深0 深1
- 只有一个根 root
- 有几个子节点叫做有几个度，度为0的叫叶（叶子）
- 有共同父节点的同级节点是兄弟节点（sibling）
- 连接节点的线叫边，树是由若干个节点和边组成的
- 从某个节点到某个节点的边连接起来叫路径
- 树可以没有结构（空树），或者是单个节点，

#### 树的遍历（二叉树为例）

按照某种规则，不重复地访问某种树的所有节点

- 先序遍历（深度优先）
- 中序遍历（深度优先）只对二叉树有用
- 后序遍历（深度优先）
- 层序遍历（广度优先）

深度优先和广度优先

> 深度优先：遍历时先扎到底，再去找兄弟节点
>
> 广度优先：一层一层的遍历

##### 深度遍历

树的结构是自相似的（树的一部分和整体结构是相似的，树结构是可以被递归描述的），其中拿出来的这一部分叫子树，没个子树也是有自己的根节点的。

什么是先序遍历，中序遍历，后序遍历？

> 先序遍历：最先遍历根节点,第一个遍历到的是根节点(遍历顺序：根左右)
>
> 中序遍历：遍历中途会经过根节点,第一个遍历的是递归到最小子树的叶子节点(遍历顺序是：左根右)
>
> 后序遍历：最后遍历到根节点,最后一次遍历的是递归到最小子树的根节点(遍历顺序是：左右根)

#### 树的衍生

- 无序树：树中任意节点的子节点之间没有顺序关系，也称自由树
- 有序树：树种任意节点的子节点之间有顺序关系
- 二叉树：每个节点最多含有两个子树的树成为二叉树
- 完全二叉树：除了最有一层，其他各层节点树都达到最大
- 满二叉树：每一层上的节点树都是最大节点树
- 霍夫曼树：带权路径最短的二叉树，也叫最优二叉树

### 前端中的数据结构应用

- 常识级别的数据结构与算法
- 传统前端的核心是DOM
- 便携前端控件
- 前端游戏

# 认识算法

### 什么是算法

程序 = 数据结构 + 算法，完成某个特定任务的过程。处理流程和数据

### 算法的特征

算法的五大特征：

- 有穷性：算法必须能在执行有限个步骤之后终止（不能没完没了）
- 确切性：每一步骤必须有确切的定义 
- 输入项：有 0 个或多个输入，用来规定初始情况，所谓 0 个输入是指算法本身定出了初始条件
- 输出项：有一个或多个输出，是对输入数据处理后的结果，没有输出的算法毫无意义
- 可行性：算法中执行的人和计算步骤都是可以被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限的时间内完成（也称为有效性）

### 怎样衡量算法的好坏

- 复杂度
  - 时间复杂度
  - 空间复杂度
- 正确性
- 可读性

### 时空复杂度

时间复杂度：

> 基于CPU的运作规则，运行的次数越少，时间复杂度越低。
>
> 在代码中一次操作代表一个时间复杂度 用`N`代表

空间复杂度：

> 处理数据时消耗的内存空间，如果不需要额外的内存来运行，空间复杂度就为 0
>
> 在处理数据时，是否需要需要额外的空间，以这个数据中基本元素的大小为单位。如果需要额外的一个元素大小的单位，那么空间复杂度为 1

时间复杂度和空间复杂度是矛盾的，也就是时间换空间，空间换时间。就像一个天平，天平两端永远都不可能都在下方，我们需要做的就是尽可能维持他的平衡。在保证效率的情况下尽可能的减少空间复杂度

### 计算时空复杂度

常见的复杂度（时间复杂由小到大）：

- 常数阶 O(1)  指操作次数是有限和固定的
- 对数阶 O(logN) 对数是幂的逆运算，
- 线性阶 O(n)  是称比例增长的，是一条有斜率的直线
- 线性对数阶 O(nlogN) 
- 平方阶 O(n^2)
- 立方阶 O(n^3)
- k次方阶 O(n^k)
- 指数阶 O(2^n)

#### 如何计算复杂度

随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率也就越低。

一般做算法复杂度分析的时候，遵循以下技巧：

> 有几重循环，一般来说一重就是 O(n)，两重就是 O(n^2)，一次类推
>
> 如果有二分，则为 O(logN)，for 循环中 i 的变量翻倍就是二分 i x= 2
>
> 保留最高项，去除常数项

### 必须要掌握的基本算法

- 枚举（穷举，暴力破解法）
- 递归
- 基本排序
- 基本查找

### 枚举算法

核心思想：枚举所有可能

本质：就是从所有候选答案中去搜索正确的解，使用该算法需要满足两个条件

- 可预先确定候选答案额数量
- 候选答案的返回在求解前必须有一个确定的集合

特点：

- 枚举算法简单暴力，暴力的枚举所有可能，尽可能地尝试所有的方法
- 速度可能很慢，却是我们最应该优先考虑的
- 实现最简单，并且得到的结果总是正确的

### 递归

核心思想：通过重复将问题分解为同类的子问题而解决问题，递归是可以转化为循环，循环也可以转化为递归

特点：

- 函数可以通过调用自身来进行递归
- 递归可以完全取代循环

递归由下面两部分组成：

- 递归主体，就是要循环解决问题的代码
- 递归的跳出条件，递归不能一直递归下去，需要完成一定的条件后跳出

### 排序算法

- 冒泡排序
- 插入排序
- 选择排序
- 二叉树排序
- 快速排序
- 堆排序
- 希尔排序

### 查找算法

| 算法                 | 查找条件               |
| -------------------- | ---------------------- |
| 顺序查找             | 无序或有序队列         |
| 二分查找（折半查找） | 有序数组               |
| 二叉排序树查找       | 二叉排序树             |
| 哈希表法（散列表）   | 先创建哈希表（散列表） |
| 分块查找             | 无序或有序队列         |

# 怎样养成算法思维

养成算法思维是一个长期的过程，需要反复的练习和思考。时刻问自己几个问题：

- 结果是什么
- 步骤是什么
- 判断结果的标准是什么
- 化繁为简，把问题进行简化，去掉一些不重要的细节。
- 分而治之
  - 把问题分为两半，变成两个与原来问题同构的问题
- 化虚为实，使用另外一种形式进行替换























